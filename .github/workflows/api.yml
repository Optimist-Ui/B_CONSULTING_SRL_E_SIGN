name: E-Sign API â€“ Build, Push & Deploy

on:
  push:
    branches:
      - dev
      - uat
      - main

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    environment:
      name: ${{ github.ref_name == 'main' && 'production' || (github.ref_name == 'dev' && 'development' || github.ref_name) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set environment variables
        run: |
          # Strip any whitespace/newlines from ECR_REPO
          ECR_REPO_CLEAN=$(echo "${{ secrets.ECR_REPO_API }}" | tr -d '\n\r' | xargs)
          echo "ECR_REPO=$ECR_REPO_CLEAN" >> $GITHUB_ENV

          case "${{ github.ref_name }}" in
            dev)
              echo "ENVIRONMENT=development" >> $GITHUB_ENV
              echo "CONTAINER_NAME=esign-api-dev" >> $GITHUB_ENV
              echo "HOST_PORT=3002" >> $GITHUB_ENV
              ;;
            uat)
              echo "ENVIRONMENT=uat" >> $GITHUB_ENV
              echo "CONTAINER_NAME=esign-api-uat" >> $GITHUB_ENV
              echo "HOST_PORT=3003" >> $GITHUB_ENV
              ;;
            main)
              echo "ENVIRONMENT=production" >> $GITHUB_ENV
              echo "CONTAINER_NAME=esign-api-prod" >> $GITHUB_ENV
              echo "HOST_PORT=3001" >> $GITHUB_ENV
              ;;
            *)
              echo "ENVIRONMENT=development" >> $GITHUB_ENV
              echo "CONTAINER_NAME=esign-api-dev" >> $GITHUB_ENV
              echo "HOST_PORT=3002" >> $GITHUB_ENV
              ;;
          esac

      - name: Debug environment and secrets
        run: |
          echo "Branch: ${{ github.ref_name }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "ECR Repository: ${{ env.ECR_REPO }}"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo "Container Name: ${{ env.CONTAINER_NAME }}"
          echo "Host Port: ${{ env.HOST_PORT }}"
          echo "AWS Account ID length: ${#AWS_ACCOUNT_ID}"
          echo "AWS Account ID (first 3 digits): ${AWS_ACCOUNT_ID:0:3}"
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}

      - name: Test AWS credentials and ECR access
        run: |
          echo "Testing AWS credentials..."
          aws sts get-caller-identity
          echo "Testing ECR repository access..."
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPO }} --region ${{ env.AWS_REGION }}
          echo "Testing ECR login token generation..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} > /dev/null && echo "ECR token generated successfully" || echo "ECR token generation failed"

      - name: Build & Push image
        run: |
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          ECR_REPO="${{ env.ECR_REPO }}"
          COMMIT_SHA="${{ github.sha }}"

          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${COMMIT_SHA}"
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          echo "AWS Account ID: $AWS_ACCOUNT_ID"
          echo "AWS Region: $AWS_REGION" 
          echo "ECR Repository: $ECR_REPO"
          echo "ECR Registry: $ECR_REGISTRY"
          echo "Full IMAGE_URI: $IMAGE_URI"

          # Build the image
          echo "Building Docker image..."
          docker build -f infra/docker/Dockerfile.api -t $IMAGE_URI .

          # Login to ECR using the standard method
          echo "Logging into ECR..."
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

          if [ $? -eq 0 ]; then
            echo "ECR login successful"
            
            # Push the image
            echo "Pushing image to ECR..."
            docker push $IMAGE_URI
            
            if [ $? -eq 0 ]; then
              echo "Image push successful"
              echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV
            else
              echo "Image push failed"
              exit 1
            fi
          else
            echo "ECR login failed"
            exit 1
          fi

      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            # Set all variables INSIDE the script for reliability
            # Clean the variables to remove any whitespace/newlines
            AWS_ACCOUNT_ID=$(echo "${{ secrets.AWS_ACCOUNT_ID }}" | tr -d '\n\r' | xargs)
            AWS_REGION=$(echo "${{ env.AWS_REGION }}" | tr -d '\n\r' | xargs)
            ECR_REPO=$(echo "${{ secrets.ECR_REPO_API }}" | tr -d '\n\r' | xargs)
            COMMIT_SHA=$(echo "${{ github.sha }}" | tr -d '\n\r' | xargs)
            CONTAINER_NAME=$(echo "${{ env.CONTAINER_NAME }}" | tr -d '\n\r' | xargs)
            HOST_PORT=$(echo "${{ env.HOST_PORT }}" | tr -d '\n\r' | xargs)
            CONTAINER_PORT=$(echo "${{ secrets.PORT }}" | tr -d '\n\r' | xargs)

            # Construct the full image URI right here on the server
            IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${COMMIT_SHA}"
            ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

            # Debug output to verify variables
            echo "Debug: AWS_ACCOUNT_ID=[${AWS_ACCOUNT_ID}]"
            echo "Debug: ECR_REPO=[${ECR_REPO}]"
            echo "Debug: IMAGE_URI=[${IMAGE_URI}]"

            echo "Logging into ECR on EC2..."
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

            if [ $? -ne 0 ]; then
              echo "ECR login failed"
              exit 1
            fi

            echo "Pulling image: $IMAGE_URI"
            docker pull $IMAGE_URI

            if [ $? -ne 0 ]; then
              echo "Docker pull failed"
              exit 1
            fi

            # Stop and remove existing container (ignore errors if container doesn't exist)
            echo "Stopping existing container..."
            docker stop $CONTAINER_NAME || echo "Container $CONTAINER_NAME was not running"
            docker rm -f $CONTAINER_NAME || echo "Container $CONTAINER_NAME did not exist"

            # Create temporary env file
            echo "${{ secrets.SENDGRID_TEMPLATES }}" > /tmp/sendgrid_templates.env

            # Run new container with environment-specific variables
            echo "Starting new container..."
            docker run -d \
              --env-file /tmp/sendgrid_templates.env \
              --name $CONTAINER_NAME \
              --restart unless-stopped \
              -p ${HOST_PORT}:${CONTAINER_PORT} \
              -e PORT=${CONTAINER_PORT} \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              -e CLIENT_URL="${{ secrets.CLIENT_URL }}" \
              -e SPRYNG_API_TOKEN="${{ secrets.SPRYNG_API_TOKEN }}" \
              -e BCRYPT_ROUNDS="${{ secrets.BCRYPT_ROUNDS }}" \
              -e REMINDER_CRON="${{ secrets.REMINDER_CRON }}" \
              -e ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL }}" \
              -e SENDGRID_FROM_EMAIL="${{ secrets.SENDGRID_FROM_EMAIL }}" \
              -e SENDGRID_API_KEY="${{ secrets.SENDGRID_API_KEY }}" \
              $IMAGE_URI

            if [ $? -eq 0 ]; then
              echo "Deployment completed successfully for $CONTAINER_NAME on port $HOST_PORT"
              # Verify container is running
              docker ps | grep $CONTAINER_NAME && echo "Container is running" || echo "Container failed to start"
            else
              echo "Container deployment failed"
              exit 1
            fi

            # Clean up temporary file
            rm -f /tmp/sendgrid_templates.env
